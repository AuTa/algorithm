# [编辑距离（Edit distance）](https://leetcode-cn.com/problems/edit-distance/)

用动态规划的思想解决。

a = "horse" b = "ros"

| | |r|o|s|
|-|-|-|-|-|
| |0|1|2|3|
|h|1|1|2|3|
|o|2|2|1|2|
|r|3|2|2|2|
|s|4|3|3|2|
|e|5|4|4|3|

1. 定义 `d[i][j]`
   1. `d[i][j]` 代表 `a` 中前 `i` 个字符，变换到 `b` 中前 `j` 个字符，最短需要操作的次数
   2. 需要考虑 a 或 b 一个字母都没有，即全增加/删除的情况，所以预留 `d[0][j]` 和 `d[i][0]`

2. 状态转移
   1. 增：`d[i][j] = d[i][j - 1] + 1`；
   2. 删：`d[i][j] = d[i - 1][j] + 1`；
   3. 改：`d[i][j] = d[i - 1][j - 1] + 1`；
   4. 按顺序计算，当计算 `d[i][j]` 时，`d[i - 1][j]`、`d[i][j - 1]`、`d[i - 1][j - 1]` 均已经确定了；
   5. 配合增删改这三种操作，需要对应的 d 把操作次数加一，取三种的最小；
   6. 如果刚好这两个字母相同 `a[i - 1] = b[j - 1]`，那么可以直接参考 `d[i - 1][j - 1]`，操作不用加一。

---
[编辑距离 (Edit distance)](https://www.dreamxu.com/books/dsa/dp/edit-distance.html)
